#include <Wire.h>
#include <MAX30105.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <SPIFFS.h>

/*
 * ============================================
 * HRV MONITOR v6.3 - HÍBRIDA (v5.0 + Filtros)
 * ============================================
 */

// 1. ESTRUTURA
struct HRVSession {
  int session;
  unsigned long timestamp;
  float fc;
  float sdnn;
  float rmssd;
  float pnn50;
  int rrValid;
};

// Protótipo para evitar erro de escopo na IDE antiga
void saveSession(struct HRVSession *s);

// Hardware
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
MAX30105 particleSensor;

// Filtros
float hpPrevInput = 0, hpPrevOutput = 0;
const float HP_ALPHA = 0.85; 
const int MA_SIZE = 4;
float maBuffer[MA_SIZE];
int maIndex = 0;

float applyFilters(float input) {
  // High Pass
  float hp = HP_ALPHA * (hpPrevOutput + input - hpPrevInput);
  hpPrevInput = input;
  hpPrevOutput = hp;
  // Moving Average
  maBuffer[maIndex] = hp;
  maIndex = (maIndex + 1) % MA_SIZE;
  float sum = 0;
  for (int i = 0; i < MA_SIZE; i++) sum += maBuffer[i];
  return sum / MA_SIZE;
}

// Variáveis de Medição (Base v5.0)
const int MAX_RR = 200;
unsigned long rrIntervalsUS[MAX_RR];
float rrIntervalsMS[MAX_RR];
int rrCount = 0;
unsigned long lastBeatUS = 0, sampleStartTime = 0, bootTime = 0;
const unsigned long SAMPLE_DURATION = 60000;
float rmssd = 0, sdnn = 0, pnn50 = 0, meanHR = 0;
int sessionNumber = 0;

enum DeviceState { IDLE, COUNTDOWN, MEASURING, PROCESSING, RESULTS };
DeviceState currentState = IDLE;

// Peak Detection (Base v5.0 adaptada)
uint32_t irMin = 0, irMax = 0;
float lastFiltered = 0;
bool wasBelow = false;
const long FINGER_THRESHOLD = 30000;
unsigned long fingerDetectedTime = 0, countdownStart = 0;
const char* LOG_FILE = "/hrv_log.csv";

// Validação RR (Melhoria da v6)
bool isValidRR(unsigned long newRR_US, unsigned long lastRR_US) {
  if (newRR_US < 272000 || newRR_US > 2000000) return false;
  if (lastRR_US > 0) {
    float variation = abs((float)newRR_US - (float)lastRR_US) / (float)lastRR_US;
    if (variation > 0.50) return false; // Regra dos 50%
  }
  return true;
}

void initSPIFFS() {
  if (!SPIFFS.begin(true)) return;
  if (!SPIFFS.exists(LOG_FILE)) {
    File file = SPIFFS.open(LOG_FILE, "w");
    if (file) { file.println("Sessao,MinutosDesdeboot,FC,SDNN,RMSSD,pNN50,RRvalidos"); file.close(); }
  }
  File file = SPIFFS.open(LOG_FILE, "r");
  if (file) {
    while (file.available()) {
      String line = file.readStringUntil('\n');
      if (line.length() > 0 && isDigit(line[0])) sessionNumber++;
    }
    file.close();
  }
}

void saveSession(struct HRVSession *s) {
  File file = SPIFFS.open(LOG_FILE, "a");
  if (file) {
    file.printf("%d,%lu,%.1f,%.1f,%.1f,%.1f,%d\n", s->session, s->timestamp, s->fc, s->sdnn, s->rmssd, s->pnn50, s->rrValid);
    file.close();
    Serial.println("Dado salvo!");
  }
}

void setup() {
  Serial.begin(115200);
  bootTime = millis();
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println("Erro OLED"); while(1); }
  initSPIFFS();
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) { Serial.println("Erro Sensor"); while(1); }
  particleSensor.setup(50, 1, 2, 400, 411, 4096); 
  
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 10);
  display.println("HRV MONITOR v6.3");
  display.println("Filtros + Base v5.0");
  display.display();
  delay(2000);
  currentState = IDLE;
}

void loop() {
  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd == 'l' || cmd == 'L') {
      File file = SPIFFS.open(LOG_FILE, "r");
      while(file.available()) Serial.println(file.readStringUntil('\n'));
      file.close();
    }
    if (cmd == 'c' || cmd == 'C') { SPIFFS.remove(LOG_FILE); sessionNumber = 0; }
  }

  switch(currentState) {
    case IDLE: handleIdle(); break;
    case COUNTDOWN: handleCountdown(); break;
    case MEASURING: handleMeasurement(); break;
    case PROCESSING: calculateMetrics(); currentState = RESULTS; break;
    case RESULTS: showResultsScreen(); break;
  }
  delay(10);
}

void handleIdle() {
  uint32_t ir = particleSensor.getIR();
  if (ir > FINGER_THRESHOLD) {
    if (fingerDetectedTime == 0) fingerDetectedTime = millis();
    if (millis() - fingerDetectedTime > 1000) { currentState = COUNTDOWN; countdownStart = millis(); }
  } else fingerDetectedTime = 0;

  display.clearDisplay();
  display.setCursor(0,0);
  display.printf("v6.3 PRONTO\nSessoes: %d\n\nColoque o dedo...", sessionNumber);
  display.display();
}

void handleCountdown() {
  int secs = 5 - ((millis() - countdownStart) / 1000);
  if (particleSensor.getIR() < FINGER_THRESHOLD) { currentState = IDLE; return; }
  display.clearDisplay(); display.setTextSize(4); display.setCursor(50, 15); display.println(secs); display.display();
  if (secs <= 0) {
    rrCount = 0; lastBeatUS = micros(); sampleStartTime = millis(); 
    sessionNumber++; currentState = MEASURING;
    irMin = 0; irMax = 0; 
  }
}

void handleMeasurement() {
  uint32_t rawIR = particleSensor.getIR();
  unsigned long elapsed = millis() - sampleStartTime;
  
  if (rawIR < FINGER_THRESHOLD) { currentState = IDLE; sessionNumber--; return; }

  // FILTRAGEM
  float filtered = applyFilters(rawIR);

  // Inicialização (Warmup 2s)
  if (elapsed < 2000) {
    irMin = (irMin == 0) ? filtered : min((float)irMin, filtered);
    irMax = (irMax == 0) ? filtered : max((float)irMax, filtered);
    display.clearDisplay(); display.setCursor(0, 20); display.println("Estabilizando..."); display.display();
    return;
  }

  // Threshold adaptativo (Base v5.0)
  const float DECAY = 0.005;
  if (filtered < irMin) irMin = filtered; else irMin += (irMax - irMin) * DECAY;
  if (filtered > irMax) irMax = filtered; else irMax -= (irMax - irMin) * DECAY;
  
  float threshold = (irMin + irMax) / 2;
  unsigned long now = micros();

  // Detecção (Base v5.0 sobre sinal filtrado)
  if (lastFiltered < threshold && filtered >= threshold && wasBelow && (now - lastBeatUS > 300000)) {
    unsigned long delta = now - lastBeatUS;
    if (isValidRR(delta, (rrCount > 0) ? rrIntervalsUS[rrCount-1] : 0) && rrCount < MAX_RR) {
      rrIntervalsUS[rrCount] = delta;
      rrIntervalsMS[rrCount] = delta / 1000.0;
      rrCount++;
      display.fillCircle(120, 10, 3, SSD1306_WHITE);
    }
    lastBeatUS = now;
  }
  wasBelow = (filtered < threshold);
  lastFiltered = filtered;

  // Display
  static unsigned long lastDisp = 0;
  if (millis() - lastDisp > 200) {
    lastDisp = millis();
    display.clearDisplay(); display.setTextSize(1); display.setCursor(0,0);
    display.printf("Sessao #%d\nBatimentos: %d\n", sessionNumber, rrCount);
    int progress = (elapsed * 128) / SAMPLE_DURATION;
    display.drawRect(0, 45, 128, 8, SSD1306_WHITE);
    display.fillRect(0, 45, progress, 8, SSD1306_WHITE);
    display.display();
  }

  if (elapsed >= SAMPLE_DURATION) currentState = PROCESSING;
}

void calculateMetrics() {
  if (rrCount < 10) return;
  float sumRR = 0, sumSqDiff = 0, sumSqSuccDiff = 0;
  int nn50 = 0;
  for (int i = 0; i < rrCount; i++) sumRR += rrIntervalsMS[i];
  float avgRR = sumRR / rrCount;
  meanHR = 60000.0 / avgRR;
  for (int i = 0; i < rrCount; i++) {
    float diff = rrIntervalsMS[i] - avgRR;
    sumSqDiff += diff * diff;
    if (i > 0) {
      float sDiff = abs(rrIntervalsMS[i] - rrIntervalsMS[i-1]);
      sumSqSuccDiff += sDiff * sDiff;
      if (sDiff > 50) nn50++;
    }
  }
  sdnn = sqrt(sumSqDiff / rrCount);
  rmssd = sqrt(sumSqSuccDiff / (rrCount - 1));
  pnn50 = (nn50 * 100.0) / (rrCount - 1);
  struct HRVSession s = {sessionNumber, (millis() - bootTime)/60000, meanHR, sdnn, rmssd, pnn50, rrCount};
  saveSession(&s);
}

void showResultsScreen() {
  display.clearDisplay(); display.setTextSize(1); display.setCursor(0,0);
  display.printf("FIM #%d\nFC: %.1f\nRMSSD: %.1f\nSDNN: %.1f\nN: %d\n", sessionNumber, meanHR, rmssd, sdnn, rrCount);
  display.display();
  if (particleSensor.getIR() < FINGER_THRESHOLD) currentState = IDLE;
}
